export { beforeToryx, afterToryx}

const beforeToryx = "async function getUserData(id: string) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    try {\n      const data = await response.json();\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      \n      if (!data.email) {\n        throw new Error('Invalid user data');\n      }\n      \n      return data;\n      \n    } catch (parseError) {\n      console.error('Parse failed:', parseError);\n      throw parseError;\n    }\n    \n  } catch (error) {\n    console.error('Request failed:', error);\n    // What do we return here? null? undefined?\n    // Caller has no idea what went wrong\n    return null;\n  }\n}\n\n// Caller has no type safety\nconst user = await getUserData('123');\n// Is user null? Did it throw? Who knows! ðŸ¤·\nif (user) {\n  console.log(user.email);\n}"
const afterToryx = "async function getUserData(id: string) {\n  const result = await safeFetch(fetch(`/api/users/${id}`));\n  return result;\n}\n\n// Caller has FULL type safety and control\nconst result = await getUserData('123');\n\nif (result.ok) {\n  const user = result.unwrap();\n  console.log(user.email); // TypeScript knows this is safe\n} else {\n  const error = result.unwrapErr();\n  console.error('Failed:', error.message); // Handle gracefully\n}"
